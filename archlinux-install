#!/usr/bin/env bash

# LICENSE
# archlinux-install, a very quick Arch Linux base installation script.
# Copyright (C) 2021  Rawleenc
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# DISCLAIMER
# archlinux-install  Copyright (C) 2021  Rawleenc
#
# This program comes with ABSOLUTELY NO WARRANTY; See the
# GNU General Public License for more details.
#
# This is free software, and you are welcome to redistribute it
# under certain conditions; See the GNU General Public License for more details.

set -Eeo pipefail
[[ "$UID" -eq 0 ]] || exec sudo bash "$0" "$@"

RED="\033[0;31m"
GREEN="\033[0;32m"
CYAN="\033[0;36m"
ORANGE="\033[0;33m"
NOCOLOR="\033[0m"

export TEXTDOMAIN=archlinux-install

# shellcheck source=/dev/null
. gettext.sh

function print-error {
    echo -e "\n${RED}  /!\ ${1}${NOCOLOR}\n"
    pause
}

function print-step {
    if test "${1}" = true; then
        clear
    fi
    echo -e "\n${GREEN}${2}${NOCOLOR}"
}

function print-sub-step {
    echo -e "${CYAN}  * ${1}${NOCOLOR}"
}

function prompt {
    declare -n variable=${2}
    read -erp "$(echo -e "${ORANGE}${1}${NOCOLOR}")" variable
}

function promptln {
    declare -n variable=${2}
    echo -e "${ORANGE}${1}${NOCOLOR}"
    read -er variable
}

function prompt-bool-default-no {
    declare -n variable=${2}
    read -erp "$(echo -e "${ORANGE}${1}${NOCOLOR}")" variable
    if test "$variable" = "y" || test "$variable" = "Y" || test "$variable" = "o" || test "$variable" = "O"; then
        variable=true
    else
        variable=false
    fi
}

function prompt-bool-default-yes {
    declare -n variable=$2
    read -erp "$(echo -e "${ORANGE}${1}${NOCOLOR}")" variable
    if test "$variable" = "n" || test "$variable" = "N"; then
        variable=false
    else
        variable=true
    fi
}

function prompt-passwd {
    declare -n variable=$2
    read -s -r -p "$(echo -e "${ORANGE}${1}${NOCOLOR}")" variable
    echo ""
}

function pause {
    read -n 1 -srp "$(echo -e "${ORANGE}$(eval_gettext "Press any key to continue...")${NOCOLOR}")"
    echo -e "\n"
}

function locale-setup {
    print-step false "$(eval_gettext "Configuring live environment...")"
    loadkeys "${KEYMAP}"
    setfont eurlatgr
    if test "${GLOBAL_LANGUAGE}" = "FR"; then
        sed -i "s|#fr_FR.UTF-8 UTF-8|fr_FR.UTF-8 UTF-8|g" /etc/locale.gen
        locale-gen
        export LANG=fr_FR.UTF-8
        export LANGUAGE=fr_FR.UTF-8
    else
        export LANG=en_US.UTF-8
        export LANGUAGE=en_US.UTF-8
    fi
}

function setup-chroot-keyboard {
    arch-chroot /mnt bash -c "mkdir --parent /etc/X11/xorg.conf.d"
    arch-chroot /mnt bash -c "echo 'Section \"InputClass\"' > /etc/X11/xorg.conf.d/00-keyboard.conf"
    arch-chroot /mnt bash -c "echo '    Identifier \"system-keyboard\"' >> /etc/X11/xorg.conf.d/00-keyboard.conf"
    arch-chroot /mnt bash -c "echo '    MatchIsKeyboard \"on\"' >> /etc/X11/xorg.conf.d/00-keyboard.conf"
    arch-chroot /mnt bash -c "echo '    Option \"XkbLayout\" \"${1}\"' >> /etc/X11/xorg.conf.d/00-keyboard.conf"
    arch-chroot /mnt bash -c "echo 'EndSection' >> /etc/X11/xorg.conf.d/00-keyboard.conf"
}

function ask-swapfile-size {
    SWAPFILE_OK=false
    while [[ $SWAPFILE_OK != true ]]; do
        prompt "$(eval_gettext "Swapfile size ? (Example: 8G, leave empty if none) : ")" SWAPFILE_SIZE
        if [[ -z $SWAPFILE_SIZE ]] || [[ $SWAPFILE_SIZE =~ ^([0-9]*[\.,][0-9][0-9]*|[0-9][0-9]*)([GMk])$ ]]; then
            SWAPFILE_OK=true
        else
            print-error "$(eval_gettext "Invalid swapfile size.")"
        fi
    done
}

function manual-partitioning {
    USER_ANSWER=false
    declare -a PARTITIONED_DISKS
    while [[ $USER_ANSWER != true ]]; do
        print-step true "$(eval_gettext "Manual partitioning :")"
        fdisk -l
        prompt "$(eval_gettext "Which drive do you want to partition ? (type the entire name, for example '/dev/sda') : ")" TARGET_DISK
        # Required fields
        if [[ ! -e "$TARGET_DISK" ]]; then
            print-error "$(eval_gettext "The chosen target drive doesn't exist.")"
            continue
        fi

        ALREADY_ADDED_DRIVE=false
        for disk in "${PARTITIONED_DISKS[@]}"; do
            if test "${TARGET_DISK}" = "${disk}"; then
                ALREADY_ADDED_DRIVE=true
            fi
        done
        if [[ $ALREADY_ADDED_DRIVE = false ]]; then
            PARTITIONED_DISKS+=("${TARGET_DISK}")
        fi

        cfdisk "$TARGET_DISK"

        print-step true "$(eval_gettext "Manual partitioning :")"
        fdisk -l
        prompt-bool-default-no "$(eval_gettext "Do you want to partition an other drive ? (y/N) : ")" OTHER_DRIVE
        if [[ $OTHER_DRIVE = true ]]; then
            continue
        fi

        set +Eeo pipefail
        for disk in "${PARTITIONED_DISKS[@]}"; do
            DETECTED_PARTITIONS=$(lsblk -nl "${disk}" -o PATH,PARTTYPENAME | grep -iE 'linux|efi|swap' | awk '{print $1}')
            for partition in $DETECTED_PARTITIONS; do
                PARTITIONS+=("${partition}")
            done
        done
        set -Eeo pipefail

        EFI_OK=false
        ROOT_OK=false
        SWAP_OK=false
        print-step true "$(eval_gettext "Detected target drive partitions :") (${PARTITIONS[*]})"
        for partition in "${PARTITIONS[@]}"; do
            print-sub-step "$(eval_gettext "Partition") : $(lsblk -nl "$partition" -o PATH,SIZE,PARTTYPENAME)"
            if [[ $BIOS = true ]]; then
                prompt "$(eval_gettext "What is the role of this partition ? (1: Root, 2: Home, 3: Swap, 4: Not used, other: Other) : ")" TYPE
            else
                prompt "$(eval_gettext "What is the role of this partition ? (0: EFI, 1: Root, 2: Home, 3: Swap, 4: Not used, other: Other) : ")" TYPE
            fi
            if [[ $BIOS = false ]] && test "$TYPE" = "0"; then
                PART_TYPE["$partition"]="EFI"
                PART_MOUNT_POINT["$partition"]="/boot/efi"
                prompt-bool-default-yes "$(eval_gettext "Format the EFI partition ? (Y/n) : ")" PART_FORMAT["$partition"]
                EFI_OK=true
            elif test "$TYPE" = "1"; then
                PART_TYPE["$partition"]="ROOT"
                PART_MOUNT_POINT["$partition"]="/"
                ROOT_OK=true
                ROOT_PARTITION="$partition"
            elif test "$TYPE" = "2"; then
                PART_TYPE["$partition"]="HOME"
                PART_MOUNT_POINT["$partition"]="/home"
                prompt-bool-default-yes "$(eval_gettext "Format the Home partition ? (Y/n) : ")" PART_FORMAT["$partition"]
            elif test "$TYPE" = "3"; then
                PART_TYPE["$partition"]="SWAP"
                SWAP_OK=true
                SWAP_PARTITION="$partition"
            elif test "$TYPE" = "4"; then
                continue
            else
                PART_TYPE["$partition"]="OTHER"
                prompt "$(eval_gettext "What is the mounting point of this partition ? : ")" MOUNT_POINT
                PART_MOUNT_POINT["$partition"]="$MOUNT_POINT"
                prompt-bool-default-yes "$(eval_gettext "Format the \${partition} partition ? (Y/n) : ")" PART_FORMAT["$partition"]
                if [[ "$MOUNT_POINT" == *"/boot"* ]]; then
                    MAIN_DISK=${TARGET_DISK}
                fi
            fi
        done
        if [[ $SWAP_OK = false ]]; then
            ask-swapfile-size
        fi
        if [[ $BIOS = false ]] && [[ $EFI_OK = false ]]; then
            print-error "$(eval_gettext "The EFI partition is required for system installation.")"
            continue
        fi
        if [[ $ROOT_OK = false ]]; then
            print-error "$(eval_gettext "The Root partition is required for system installation.")"
            continue
        fi
        print-step true "$(eval_gettext "Summary of choices :")"
        for partition in "${PARTITIONS[@]}"; do
            if [[ -n ${PART_FORMAT[${partition}]} ]]; then
                if [[ ${PART_FORMAT[${partition}]} = true ]]; then
                    FORMATTING="$(eval_gettext "yes")"
                else
                    FORMATTING="$(eval_gettext "no")"
                fi
            fi
            if test "${PART_TYPE[${partition}]}" = "EFI"; then
                print-sub-step "$(eval_gettext "EFI partition") : ${partition} ($(eval_gettext "mounting point") : ${PART_MOUNT_POINT[${partition}]}, $(eval_gettext "Format") : ${FORMATTING})"
            elif test "${PART_TYPE[${partition}]}" = "ROOT"; then
                print-sub-step "$(eval_gettext "ROOT partition") : ${partition} ($(eval_gettext "mounting point") : ${PART_MOUNT_POINT[${partition}]})"
            elif test "${PART_TYPE[${partition}]}" = "HOME"; then
                print-sub-step "$(eval_gettext "Home partition") : ${partition} ($(eval_gettext "mounting point") : ${PART_MOUNT_POINT[${partition}]}, $(eval_gettext "Format") : ${FORMATTING})"
            elif test "${PART_TYPE[${partition}]}" = "SWAP"; then
                print-sub-step "$(eval_gettext "Swap partition") : ${partition}"
            elif test "${PART_TYPE[${partition}]}" = "OTHER"; then
                print-sub-step "$(eval_gettext "Other partition") : ${partition} ($(eval_gettext "mounting point") : ${PART_MOUNT_POINT[${partition}]}, $(eval_gettext "Format") : ${FORMATTING})"
            fi
        done
        if [[ $SWAP_OK = false ]] && [[ -n "$SWAPFILE_SIZE" ]]; then
            print-sub-step "$(eval_gettext "Swapfile size") : $SWAPFILE_SIZE"
        fi
        prompt-bool-default-no "$(eval_gettext "Is the informations correct ? (y/N) : ")" USER_ANSWER
    done
}

function build-partition-name {
    if [[ "${1}" == *"nvme"* ]]; then
        echo "${1}p${2}"
    else
        echo "${1}${2}"
    fi
}

function auto-partitioning {
    USER_ANSWER=false
    while [[ $USER_ANSWER != true ]]; do
        print-step true "$(eval_gettext "Automatic partitioning :")"
        fdisk -l
        prompt "$(eval_gettext "On which drive should Archlinux be installed ? (type the entire name, for example '/dev/sda') : ")" TARGET_DISK
        if [[ -z "$TARGET_DISK" ]]; then
            print-error "$(eval_gettext "You need to choose a target drive.")"
            continue
        fi
        if [[ ! -e "$TARGET_DISK" ]]; then
            print-error "$(eval_gettext "The chosen target drive doesn't exist.")"
            continue
        fi
        prompt "$(eval_gettext "What type of Swap do you want ? (1: Partition, other: File) : ")" SWAP_TYPE
        prompt-bool-default-no "$(eval_gettext "Do you want a separated Home ? (y/N) : ")" WANT_HOME
        MAIN_DISK=${TARGET_DISK}
        TARGET_DISK_SIZE=$(lsblk -b --output SIZE -n -d "${TARGET_DISK}")
        ((ROOT_SIZE = TARGET_DISK_SIZE / 4))
        ((SWAP_SIZE = TARGET_DISK_SIZE / 32))
        ROOT_SIZE=$(echo "${ROOT_SIZE}" | numfmt --to=iec)
        SWAP_SIZE=$(echo "${SWAP_SIZE}" | numfmt --to=iec)
        SWAP_OK=false
        if test "$SWAP_TYPE" = "1"; then
            SWAP_OK=true
        else
            SWAPFILE_SIZE="${SWAP_SIZE}"
        fi

        if [[ $BIOS = true ]]; then
            # DOS LABEL
            AUTOPARTSTR="o\n" # Create a new empty DOS partition table
            # BOOT
            AUTOPARTSTR+="n\n"   # Add a new partition
            AUTOPARTSTR+="p\n"   # Partition primary (Accept default: primary)
            AUTOPARTSTR+=" \n"   # Partition number (Accept default: auto)
            AUTOPARTSTR+=" \n"   # First sector (Accept default: 1)
            AUTOPARTSTR+="+1G\n" # Last sector (Accept default: varies)
            AUTOPARTSTR+="a\n"   # Toggle bootable flag

            INDEX=1
            PARTITION=$(build-partition-name "${TARGET_DISK}" "${INDEX}")
            PART_TYPE["${PARTITION}"]="OTHER"
            PART_MOUNT_POINT["${PARTITION}"]="/boot"
            PART_FORMAT["${PARTITION}"]=true
            PARTITIONS+=("${PARTITION}")
        else
            # GPT LABEL
            AUTOPARTSTR="g\n" # Create a new empty GPT partition table
            # EFI
            AUTOPARTSTR+="n\n"     # Add a new partition
            AUTOPARTSTR+=" \n"     # Partition number (Accept default: auto)
            AUTOPARTSTR+=" \n"     # First sector (Accept default: 1)
            AUTOPARTSTR+="+512M\n" # Last sector (Accept default: varies)
            AUTOPARTSTR+="t\n"     # Change partition type
            AUTOPARTSTR+=" \n"     # Partition number (Accept default: auto)
            AUTOPARTSTR+="1\n"     # Type EFI System

            INDEX=1
            PARTITION=$(build-partition-name "${TARGET_DISK}" "${INDEX}")
            PART_TYPE["${PARTITION}"]="EFI"
            PART_MOUNT_POINT["${PARTITION}"]="/boot/efi"
            PART_FORMAT["${PARTITION}"]=true
            PARTITIONS+=("$PARTITION")
        fi
        if test "$SWAP_TYPE" = "1"; then
            # SWAP
            AUTOPARTSTR+="n\n" # Add a new partition
            if [[ $BIOS = true ]]; then
                AUTOPARTSTR+="p\n" # Partition primary (Accept default: primary)
            fi
            AUTOPARTSTR+=" \n"             # Partition number (Accept default: auto)
            AUTOPARTSTR+=" \n"             # First sector (Accept default: 1)
            AUTOPARTSTR+="+${SWAP_SIZE}\n" # Last sector (Accept default: varies)
            AUTOPARTSTR+="t\n"             # Change partition type
            AUTOPARTSTR+=" \n"             # Partition number (Accept default: auto)
            if [[ $BIOS = true ]]; then
                AUTOPARTSTR+="82\n" # Type Linux Swap
            else
                AUTOPARTSTR+="19\n" # Type Linux Swap
            fi

            ((INDEX = INDEX + 1))
            PARTITION=$(build-partition-name "${TARGET_DISK}" "${INDEX}")
            PART_TYPE["${PARTITION}"]="SWAP"
            PARTITIONS+=("${PARTITION}")
        fi
        if [[ $WANT_HOME = true ]]; then
            # ROOT
            AUTOPARTSTR+="n\n" # Add a new partition
            if [[ $BIOS = true ]]; then
                AUTOPARTSTR+="p\n" # Partition primary (Accept default: primary)
            fi
            AUTOPARTSTR+=" \n"             # Partition number (Accept default: auto)
            AUTOPARTSTR+=" \n"             # First sector (Accept default: 1)
            AUTOPARTSTR+="+${ROOT_SIZE}\n" # Last sector (Accept default: varies)

            ((INDEX = INDEX + 1))
            PARTITION=$(build-partition-name "${TARGET_DISK}" "${INDEX}")
            PART_TYPE["${PARTITION}"]="ROOT"
            PART_MOUNT_POINT["${PARTITION}"]="/"
            ROOT_PARTITION="${PARTITION}"
            PARTITIONS+=("${PARTITION}")
            # HOME
            AUTOPARTSTR+="n\n" # Add a new partition
            if [[ $BIOS = true ]]; then
                AUTOPARTSTR+="p\n" # Partition primary (Accept default: primary)
            fi
            AUTOPARTSTR+=" \n" # Partition number (Accept default: auto)
            AUTOPARTSTR+=" \n" # First sector (Accept default: 1)
            AUTOPARTSTR+=" \n" # Last sector (Accept default: varies)

            ((INDEX = INDEX + 1))
            PARTITION=$(build-partition-name "${TARGET_DISK}" "${INDEX}")
            PART_TYPE["${PARTITION}"]="HOME"
            PART_MOUNT_POINT["${PARTITION}"]="/home"
            PART_FORMAT["${PARTITION}"]=true
            PARTITIONS+=("${PARTITION}")
        else
            # ROOT
            AUTOPARTSTR+="n\n" # Add a new partition
            if [[ $BIOS = true ]]; then
                AUTOPARTSTR+="p\n" # Partition primary (Accept default: primary)
            fi
            AUTOPARTSTR+=" \n" # Partition number (Accept default: auto)
            AUTOPARTSTR+=" \n" # First sector (Accept default: 1)
            AUTOPARTSTR+=" \n" # Last sector (Accept default: varies)

            ((INDEX = INDEX + 1))
            PARTITION=$(build-partition-name "${TARGET_DISK}" "${INDEX}")
            PART_TYPE["${PARTITION}"]="ROOT"
            PART_MOUNT_POINT["${PARTITION}"]="/"
            ROOT_PARTITION="${PARTITION}"
            PARTITIONS+=("${PARTITION}")
        fi
        # WRITE
        AUTOPARTSTR+="w\n"

        echo -e "${AUTOPARTSTR}" | fdisk "${TARGET_DISK}" &>/dev/null

        print-step false "$(eval_gettext "Summary of choices :")"
        for partition in "${PARTITIONS[@]}"; do
            if [[ -n ${PART_FORMAT[${partition}]} ]]; then
                if [[ ${PART_FORMAT[${partition}]} = true ]]; then
                    FORMATTING="$(eval_gettext "yes")"
                else
                    FORMATTING="$(eval_gettext "no")"
                fi
            fi
            if test "${PART_TYPE[${partition}]}" = "EFI"; then
                print-sub-step "$(eval_gettext "EFI partition") : ${partition} ($(eval_gettext "mounting point") : ${PART_MOUNT_POINT[${partition}]}, $(eval_gettext "Format") : ${FORMATTING})"
            elif test "${PART_TYPE[${partition}]}" = "ROOT"; then
                print-sub-step "$(eval_gettext "ROOT partition") : ${partition} ($(eval_gettext "mounting point") : ${PART_MOUNT_POINT[${partition}]})"
            elif test "${PART_TYPE[${partition}]}" = "HOME"; then
                print-sub-step "$(eval_gettext "Home partition") : ${partition} ($(eval_gettext "mounting point") : ${PART_MOUNT_POINT[${partition}]}, $(eval_gettext "Format") : ${FORMATTING})"
            elif test "${PART_TYPE[${partition}]}" = "SWAP"; then
                print-sub-step "$(eval_gettext "Swap partition") : ${partition}"
            elif test "${PART_TYPE[${partition}]}" = "OTHER"; then
                print-sub-step "$(eval_gettext "Other partition") : ${partition} ($(eval_gettext "mounting point") : ${PART_MOUNT_POINT[${partition}]}, $(eval_gettext "Format") : ${FORMATTING})"
            fi
        done
        if [[ $SWAP_OK = false ]] && [[ -n "$SWAPFILE_SIZE" ]]; then
            print-sub-step "$(eval_gettext "Swapfile size") : $SWAPFILE_SIZE"
        fi

        prompt-bool-default-no "$(eval_gettext "Is the informations correct ? (y/N) : ")" USER_ANSWER
    done
}

print-step false "$(eval_gettext "Running pre-launch steps : ")"
print-sub-step "$(eval_gettext "Synchronising repositories...")"
pacman -Sy &>/dev/null

print-sub-step "$(eval_gettext "Downloading and formatting translations...")"
if [[ ! -f "fr.po" ]]; then
    curl --silent -sLO "raw.githubusercontent.com/rawleenc/archlinux-install/dev/locales/fr.po"
fi
msgfmt -o /usr/share/locale/fr/LC_MESSAGES/archlinux-install.mo fr.po &>/dev/null

print-sub-step "$(eval_gettext "Querying IP geolocation language...")"
DETECTED_LANGUAGE=$(curl --silent --fail https://ipapi.co/languages | awk -F ',' '{print $1}')

print-sub-step "$(eval_gettext "Querying IP geolocation timezone...")"
DETECTED_TIMEZONE=$(curl --silent --fail https://ipapi.co/timezone)

print-sub-step "$(eval_gettext "Querying IP geolocation country code...")"
DETECTED_COUNTRY_CODE=$(curl --silent --fail https://ipapi.co/country)

USER_ANSWER=false
while [[ $USER_ANSWER != true ]]; do
    print-step true "$(eval_gettext "Welcome to the archlinux-install script !")"
    if [[ ! -d "/sys/firmware/efi" ]]; then
        BIOS=true
        print-error "$(eval_gettext "BIOS detected ! The script will act accordingly. Don't forget to select a DOS label type before partitioning.")"
    else
        BIOS=false
    fi

    print-step false "$(eval_gettext "Environment configuration : ")"

    declare -a SUPPORTED_GLOBAL_LANGUAGES=("FR" "EN")
    if test "${DETECTED_LANGUAGE}" = "fr-FR"; then
        DEFAULT_LANGUAGE="FR"
    else
        DEFAULT_LANGUAGE="EN"
    fi
    GLOBAL_LANGUAGE_OK=false
    while [[ $GLOBAL_LANGUAGE_OK != true ]]; do
        promptln "$(eval_gettext "Choose your installation's language") (${DEFAULT_LANGUAGE}, $(eval_gettext "type 'h' or 'help' to list supported languages")) : " GLOBAL_LANGUAGE
        if [[ -z ${GLOBAL_LANGUAGE} ]]; then
            GLOBAL_LANGUAGE="${DEFAULT_LANGUAGE}"
        fi
        if test "${GLOBAL_LANGUAGE}" = "h" || test "${GLOBAL_LANGUAGE}" = "help"; then
            print-step false "$(eval_gettext "Supported languages : ")"
            for language in "${SUPPORTED_GLOBAL_LANGUAGES[@]}"; do
                print-sub-step "${language}"
            done
            echo ""
            pause
            continue
        fi
        GLOBAL_LANGUAGE="${GLOBAL_LANGUAGE^^}"
        if [[ "${SUPPORTED_GLOBAL_LANGUAGES[*]}" == *"${GLOBAL_LANGUAGE}"* ]]; then
            GLOBAL_LANGUAGE_OK=true
        else
            print-error "$(eval_gettext "Global language \${GLOBAL_LANGUAGE} is not supported.")"
            continue
        fi
    done

    if test "${DETECTED_LANGUAGE}" = "fr-FR"; then
        DEFAULT_KEYMAP="fr-latin9"
    else
        DEFAULT_KEYMAP="de-latin1"
    fi

    KEYMAP_OK=false
    while [[ $KEYMAP_OK != true ]]; do
        promptln "$(eval_gettext "Type your installation's keymap") (${DEFAULT_KEYMAP}) : " KEYMAP
        if [[ -z "$KEYMAP" ]]; then
            KEYMAP="${DEFAULT_KEYMAP}"
        fi
        if localectl list-keymaps | grep "^${KEYMAP}$" &>/dev/null; then
            KEYMAP_OK=true
        else
            print-error "$(eval_gettext "Keymap \${KEYMAP} doesn't exist.")"
            continue
        fi
    done

    print-step false "$(eval_gettext "Summary of choices :")"
    print-sub-step "$(eval_gettext "Your installation's language") : $GLOBAL_LANGUAGE"
    print-sub-step "$(eval_gettext "Your installation's keymap") : $KEYMAP"
    prompt-bool-default-no "$(eval_gettext "Is the informations correct ? (y/N) : ")" USER_ANSWER
done

locale-setup

USER_ANSWER=false
while [[ $USER_ANSWER != true ]]; do
    print-step true "$(eval_gettext "System configuration : ")"
    prompt "$(eval_gettext "What will be your hostname (archlinux) : ")" HOSTNAME
    prompt-bool-default-no "$(eval_gettext "Install LTS Linux kernel ? (y/N) : ")" LTS_KERNEL
    prompt-bool-default-no "$(eval_gettext "Install proprietary Nvidia driver ? (y/N) : ")" NVIDIA_DRIVER
    prompt-bool-default-no "$(eval_gettext "Install terminus console font ? (y/N) : ")" TERMINUS_FONT
    prompt "$(eval_gettext "Install a desktop environment ? (1: Gnome, 2: KDE Plasma, 3: XFCE, other: None) : ")" DESKTOP
    if [[ -n "$DESKTOP" ]] && test "$DESKTOP" = "2"; then
        prompt-bool-default-no "$(eval_gettext "Install Wayland support for the plasma session ? (y/N) : ")" PLASMA_WAYLAND
    fi
    prompt-bool-default-no "$(eval_gettext "Install Cups ? (y/N) : ")" CUPS
    prompt-bool-default-no "$(eval_gettext "Install ZSH with GRML configuration ? (y/N) : ")" GRML_ZSH
    prompt-bool-default-no "$(eval_gettext "Install a set of main fonts ? (y/N) : ")" MAIN_FONTS
    prompt-bool-default-no "$(eval_gettext "Install main file systems support ? (y/N) : ")" MAIN_FILE_SYSTEMS
    DEFAULT_TIMEZONE_FILE="/usr/share/zoneinfo/${DETECTED_TIMEZONE}"
    promptln "$(eval_gettext "Your timezone") (${DEFAULT_TIMEZONE_FILE}) : " TIMEZONE
    promptln "$(eval_gettext "Would you like to add a user? (username, leave blank if none) : ")" USER_NAME
    if [[ -n "$USER_NAME" ]]; then
        promptln "$(eval_gettext "What is the \${USER_NAME}'s full name (type the entire full name, leave blank if none) : ")" USER_FULL_NAME
    fi
    set +Eeo pipefail
    PKGS_SELECT_OK=false
    while [[ $PKGS_SELECT_OK != true ]]; do
        PKGS_SELECT_OK=true
        promptln "$(eval_gettext "Install more packages ? (type extra packages full names, example : 'htop neofetch', leave blank if none) : ")" MORE_PKGS
        IFS=" " read -r -a MORE_PKGS_ARRAY <<<"${MORE_PKGS}"
        for pkg in "${MORE_PKGS_ARRAY[@]}"; do
            if pacman -Ss ^"${pkg}"$ &>/dev/null; then
                PKGS_SELECT_OK=true
            else
                PKGS_SELECT_OK=false
                print-error "$(eval_gettext "Package \${pkg} doesn't exist.")"
                break
            fi
        done
    done
    set -Eeo pipefail

    ROOT_PASSWORD_CONFIRM="wrong"
    while test "$ROOT_PASSWORD" != "$ROOT_PASSWORD_CONFIRM"; do
        print-sub-step "$(eval_gettext "root password configuration : ")"
        prompt-passwd "$(eval_gettext "Enter the root password : ")" ROOT_PASSWORD
        prompt-passwd "$(eval_gettext "Re-enter the root password to confirm : ")" ROOT_PASSWORD_CONFIRM
        if test "$ROOT_PASSWORD" != "$ROOT_PASSWORD_CONFIRM"; then
            print-error "$(eval_gettext "Passwords entered don't match.")"
        fi
    done

    if [[ -n "$USER_NAME" ]]; then
        USER_PASSWORD_CONFIRM="wrong"
        while test "$USER_PASSWORD" != "$USER_PASSWORD_CONFIRM"; do
            print-sub-step "$(eval_gettext "\${USER_NAME} password configuration : ")"
            prompt-passwd "$(eval_gettext "Enter the \${USER_NAME} password : ")" USER_PASSWORD
            prompt-passwd "$(eval_gettext "Re-enter the \${USER_NAME} password to confirm : ")" USER_PASSWORD_CONFIRM
            if test "$USER_PASSWORD" != "$USER_PASSWORD_CONFIRM"; then
                print-error "$(eval_gettext "Passwords entered don't match.")"
            fi
        done
    fi

    # Default values
    if [[ -z "$HOSTNAME" ]]; then
        HOSTNAME="archlinux"
    fi
    if test "$DESKTOP" = "1"; then
        DESKTOP="gnome"
    elif test "$DESKTOP" = "2"; then
        DESKTOP="plasma"
    elif test "$DESKTOP" = "3"; then
        DESKTOP="xfce"
    else
        DESKTOP="$(eval_gettext "none")"
    fi
    if [[ -z "$TIMEZONE" ]]; then
        TIMEZONE="${DEFAULT_TIMEZONE_FILE}"
    fi
    MICROCODES=$(grep </proc/cpuinfo 'vendor' | uniq | cut -f 2 -d ":" | awk '{$1=$1}1')

    print-step true "$(eval_gettext "Summary of choices :")"
    print-sub-step "$(eval_gettext "Your hostname") : $HOSTNAME"
    if test "$MICROCODES" = "GenuineIntel" || test "$MICROCODES" = "AuthenticAMD"; then
        print-sub-step "$(eval_gettext "Microcodes to install") : $MICROCODES"
    fi
    if [[ $LTS_KERNEL = true ]]; then
        print-sub-step "$(eval_gettext "Install LTS Linux kernel.")"
    fi
    if [[ $NVIDIA_DRIVER = true ]]; then
        print-sub-step "$(eval_gettext "Install proprietary Nvidia driver.")"
    fi
    if [[ $TERMINUS_FONT = true ]]; then
        print-sub-step "$(eval_gettext "Install terminus console font.")"
    fi
    print-sub-step "$(eval_gettext "Desktop environment") : $DESKTOP"
    if test "$DESKTOP" = "plasma"; then
        if [[ $PLASMA_WAYLAND = true ]]; then
            print-sub-step "$(eval_gettext "Install Wayland support for the plasma session.")"
        fi
    fi
    if [[ $CUPS = true ]]; then
        print-sub-step "$(eval_gettext "Install Cups.")"
    fi
    if [[ $GRML_ZSH = true ]]; then
        print-sub-step "$(eval_gettext "Install ZSH with GRML configuration.")"
    fi
    if [[ $MAIN_FONTS = true ]]; then
        print-sub-step "$(eval_gettext "Install a set of main fonts.")"
    fi
    if [[ $MAIN_FILE_SYSTEMS = true ]]; then
        print-sub-step "$(eval_gettext "Install main file systems support.")"
    fi
    print-sub-step "$(eval_gettext "Your timezone") : $TIMEZONE"
    if [[ -n "$USER_NAME" ]]; then
        print-sub-step "$(eval_gettext "Additional user name") : $USER_NAME"
        if [[ -n "$USER_FULL_NAME" ]]; then
            print-sub-step "$(eval_gettext "User's full name") : $USER_FULL_NAME"
        fi
    fi
    if [[ -n "$MORE_PKGS" ]]; then
        print-sub-step "$(eval_gettext "More packages to install") : ${MORE_PKGS_ARRAY[*]}"
    fi
    prompt-bool-default-no "$(eval_gettext "Is the informations correct ? (y/N) : ")" USER_ANSWER
done

# Partitioning
declare -a PARTITIONS
declare -A PART_TYPE
declare -A PART_MOUNT_POINT
declare -A PART_FORMAT

print-step true "$(eval_gettext "Partitioning :")"
prompt-bool-default-no "$(eval_gettext "Do you want an automatic partitionning ? (y/N) : ")" WANT_AUTO_PART
if [[ $WANT_AUTO_PART = true ]]; then
    auto-partitioning
else
    manual-partitioning
fi

print-step true "$(eval_gettext "Formatting and mounting partitions...")"

mkfs.ext4 "${ROOT_PARTITION}"
mkdir -p "/mnt${PART_MOUNT_POINT[${ROOT_PARTITION}]}"
mount "${ROOT_PARTITION}" "/mnt${PART_MOUNT_POINT[${ROOT_PARTITION}]}"

for partition in "${PARTITIONS[@]}"; do
    if [[ $BIOS = false ]] && test "${PART_TYPE[${partition}]}" = "EFI"; then
        if [[ ${PART_FORMAT[${partition}]} = true ]]; then
            mkfs.vfat "${partition}"
        fi
        mkdir -p "/mnt${PART_MOUNT_POINT[${partition}]}"
        mount "${partition}" "/mnt${PART_MOUNT_POINT[${partition}]}"
    elif test "${PART_TYPE[${partition}]}" = "HOME"; then
        if [[ ${PART_FORMAT[${partition}]} = true ]]; then
            mkfs.ext4 "${partition}"
        fi
        mkdir -p "/mnt${PART_MOUNT_POINT[${partition}]}"
        mount "${partition}" "/mnt${PART_MOUNT_POINT[${partition}]}"
    elif test "${PART_TYPE[${partition}]}" = "SWAP"; then
        mkswap "${partition}"
        swapon "${partition}"
    elif test "${PART_TYPE[${partition}]}" = "OTHER"; then
        if [[ ${PART_FORMAT[${partition}]} = true ]]; then
            mkfs.ext4 "${partition}"
        fi
        mkdir -p "/mnt${PART_MOUNT_POINT[${partition}]}"
        mount "${partition}" "/mnt${PART_MOUNT_POINT[${partition}]}"
    fi
done

# Creation and activation of the swapfile
if [[ $SWAP_OK = false ]] && [[ -n "$SWAPFILE_SIZE" ]]; then
    print-step false "$(eval_gettext "Creation and activation of the swapfile...")"
    fallocate -l "$SWAPFILE_SIZE" /mnt/swapfile
    chmod 600 /mnt/swapfile
    mkswap /mnt/swapfile
    swapon /mnt/swapfile
fi

# Updating mirrors
print-step false "$(eval_gettext "Updating mirrors...")"
reflector --save /etc/pacman.d/mirrorlist --protocol https --age 12 --country "${DETECTED_COUNTRY_CODE}" --score 5 --sort rate

# Installation of the base
print-step false "$(eval_gettext "Installation of the base...")"
declare -a PKGS=("base" "base-devel" "linux-firmware" "man-db" "man-pages" "texinfo" "nano" "vim" "git" "curl" "grub" "os-prober" "efibootmgr" "networkmanager" "xdg-user-dirs" "reflector" "numlockx" "ntp")
if test "$MICROCODES" = "GenuineIntel"; then
    PKGS+=("intel-ucode")
fi
if test "$MICROCODES" = "AuthenticAMD"; then
    PKGS+=("amd-ucode")
fi
if [[ $LTS_KERNEL = true ]]; then
    PKGS+=("linux-lts")
else
    PKGS+=("linux")
fi
if [[ $NVIDIA_DRIVER = true ]]; then
    if [[ $LTS_KERNEL = true ]]; then
        PKGS+=("nvidia-lts")
    else
        PKGS+=("nvidia")
    fi
fi
if [[ $TERMINUS_FONT = true ]]; then
    PKGS+=("terminus-font")
fi
if test "$DESKTOP" = "gnome"; then
    PKGS+=("gnome" "gnome-extra" "alsa-utils" "pulseaudio" "pulseaudio-alsa")
elif test "$DESKTOP" = "plasma"; then
    PKGS+=("plasma" "kde-applications" "xorg-server" "alsa-utils" "pulseaudio" "pulseaudio-alsa")
    if [[ $PLASMA_WAYLAND = true ]]; then
        PKGS+=("plasma-wayland-session")
        if [[ $NVIDIA_DRIVER = true ]]; then
            PKGS+=("egl-wayland")
        fi
    fi
elif test "$DESKTOP" = "xfce"; then
    PKGS+=("xfce4" "xfce4-goodies" "lightdm" "lightdm-gtk-greeter" "lightdm-gtk-greeter-settings" "xorg-server" "alsa-utils" "pulseaudio" "pulseaudio-alsa" "pavucontrol")
fi
if [[ $CUPS = true ]]; then
    PKGS+=("cups" "cups-pdf" "avahi" "samba" "foomatic-db-engine" "foomatic-db" "foomatic-db-ppds" "foomatic-db-nonfree-ppds" "foomatic-db-gutenprint-ppds" "gutenprint" "ghostscript")
fi
if [[ $GRML_ZSH = true ]]; then
    PKGS+=("zsh" "zsh-completions" "grml-zsh-config")
fi
if [[ $MAIN_FONTS = true ]]; then
    PKGS+=("gnu-free-fonts" "noto-fonts" "ttf-bitstream-vera" "ttf-dejavu" "ttf-hack" "ttf-droid" "ttf-fira-code" "ttf-fira-mono" "ttf-fira-sans" "ttf-font-awesome" "ttf-inconsolata" "ttf-input" "ttf-liberation" "ttf-nerd-fonts-symbols" "ttf-opensans" "ttf-roboto" "ttf-roboto-mono" "ttf-ubuntu-font-family" "ttf-jetbrains-mono")
fi
if [[ $MAIN_FILE_SYSTEMS = true ]]; then
    PKGS+=("btrfs-progs" "dosfstools" "exfatprogs" "exfat-utils" "f2fs-tools" "e2fsprogs" "jfsutils" "nilfs-utils" "ntfs-3g" "reiserfsprogs" "udftools" "xfsprogs")
fi
if [[ -n "$MORE_PKGS" ]]; then
    for pkg in "${MORE_PKGS_ARRAY[@]}"; do
        PKGS+=("${pkg}")
    done
fi
pacstrap /mnt "${PKGS[@]}"

# System configuration
print-step false "$(eval_gettext "System configuration...")"
genfstab -U /mnt >>/mnt/etc/fstab
sed -i "s|#en_US.UTF-8 UTF-8|en_US.UTF-8 UTF-8|g" /mnt/etc/locale.gen
sed -i "s|#en_US ISO-8859-1|en_US ISO-8859-1|g" /mnt/etc/locale.gen
if test "$GLOBAL_LANGUAGE" = "FR"; then
    sed -i "s|#fr_FR.UTF-8 UTF-8|fr_FR.UTF-8 UTF-8|g" /mnt/etc/locale.gen
    sed -i "s|#fr_FR ISO-8859-1|fr_FR ISO-8859-1|g" /mnt/etc/locale.gen
    echo "LANG=fr_FR.UTF-8" >/mnt/etc/locale.conf
else
    echo "LANG=en_US.UTF-8" >/mnt/etc/locale.conf
fi
echo "KEYMAP=$KEYMAP" >/mnt/etc/vconsole.conf
if [[ $TERMINUS_FONT = true ]]; then
    echo "FONT=ter-v16b" >>/mnt/etc/vconsole.conf
else
    echo "FONT=eurlatgr" >>/mnt/etc/vconsole.conf
fi
sed -i "s|#Color|Color|g" /mnt/etc/pacman.conf
echo "$HOSTNAME" >/mnt/etc/hostname
{
    echo "127.0.0.1 localhost"
    echo "::1 localhost"
    echo "127.0.1.1 $HOSTNAME.localdomain $HOSTNAME"
} >>/mnt/etc/hosts

print-step false "$(eval_gettext "Locales configuration...")"
arch-chroot /mnt bash -c "ln -sf $TIMEZONE /etc/localtime"
arch-chroot /mnt bash -c "locale-gen"
print-step false "$(eval_gettext "Network configuration...")"
arch-chroot /mnt bash -c "systemctl enable NetworkManager"
arch-chroot /mnt bash -c "systemctl enable ntpd"
print-step false "$(eval_gettext "Installation and configuration of the grub...")"
if [[ $BIOS = true ]]; then
    arch-chroot /mnt bash -c "grub-install --target=i386-pc $MAIN_DISK"
else
    arch-chroot /mnt bash -c 'grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id="Arch Linux"'
fi
arch-chroot /mnt bash -c "grub-mkconfig -o /boot/grub/grub.cfg"

print-step false "$(eval_gettext "Extra packages configuration if needed...")"
if test "$DESKTOP" = "gnome"; then
    arch-chroot /mnt bash -c "systemctl enable gdm"
    arch-chroot /mnt bash -c "amixer sset Master unmute"
    if [[ "$KEYMAP" == *"fr"* ]]; then
        setup-chroot-keyboard "fr"
    fi
fi
if test "$DESKTOP" = "plasma"; then
    arch-chroot /mnt bash -c "systemctl enable sddm"
    arch-chroot /mnt bash -c "amixer sset Master unmute"
    if [[ "$KEYMAP" == *"fr"* ]]; then
        setup-chroot-keyboard "fr"
    fi
fi
if test "$DESKTOP" = "xfce"; then
    arch-chroot /mnt bash -c "systemctl enable lightdm"
    arch-chroot /mnt bash -c "amixer sset Master unmute"
    if [[ "$KEYMAP" == *"fr"* ]]; then
        setup-chroot-keyboard "fr"
    fi
fi
if [[ $CUPS = true ]]; then
    arch-chroot /mnt bash -c "systemctl enable avahi-daemon"
    arch-chroot /mnt bash -c "systemctl enable cups"
    arch-chroot /mnt bash -c "systemctl enable cups-browsed"
fi

print-step false "$(eval_gettext "Users configuration...")"
print-sub-step "$(eval_gettext "root account configuration...")"
if [[ $GRML_ZSH = true ]]; then
    arch-chroot /mnt bash -c "chsh --shell /bin/zsh"
fi
if [[ -n ${ROOT_PASSWORD} ]]; then
    arch-chroot /mnt bash -c "echo 'root:${ROOT_PASSWORD}' | chpasswd"
fi
if [[ -n "$USER_NAME" ]]; then
    print-sub-step "$(eval_gettext "\${USER_NAME} account configuration...")"
    sed -i "s|# %wheel ALL=(ALL) ALL|%wheel ALL=(ALL) ALL|g" /mnt/etc/sudoers
    if [[ $GRML_ZSH = true ]]; then
        arch-chroot /mnt bash -c "useradd --shell=/bin/zsh --groups=wheel --create-home ${USER_NAME}"
    else
        arch-chroot /mnt bash -c "useradd --shell=/bin/bash --groups=wheel --create-home ${USER_NAME}"
    fi
    if [[ -n "$USER_FULL_NAME" ]]; then
        arch-chroot /mnt bash -c "chfn -f '${USER_FULL_NAME}' ${USER_NAME}"
    fi
    if [[ -n ${USER_PASSWORD} ]]; then
        arch-chroot /mnt bash -c "echo '${USER_NAME}:${USER_PASSWORD}' | chpasswd"
    fi
fi

# DÃ©montage des partitions
print-step false "$(eval_gettext "Unmounting partitions...")"
if [[ $SWAP_OK = false ]] && [[ -n "$SWAPFILE_SIZE" ]]; then
    swapoff /mnt/swapfile
fi
if [[ $SWAP_OK = true ]] && [[ -n "$SWAP_PARTITION" ]]; then
    swapoff "${SWAP_PARTITION}"
fi
umount -R /mnt
print-step false "$(eval_gettext "Installation complete ! You can reboot your system.")"
